using System;
using System.Collections.Concurrent;
using System.Diagnostics;
using System.Globalization;
using System.IO.Ports;
using System.Text;
using System.Threading;
using UnityEngine;
using Debug = UnityEngine.Debug;

public class SimpleMovement : MonoBehaviour
{
    private string portName = "COM3"; // Testing using Arduino
    public int baud = 115200;
    public int readTimeoutMs = 200;

    SerialPort sp;
    Thread reader;
    volatile bool running;
    readonly ConcurrentQueue<string> inbox = new ConcurrentQueue<string>();

    public float moveSpeed = 0.1f;
    public float rotationSpeed = 10f;

    // Camera follow properties
    public Transform cameraTransform; // Reference to the camera's transform
    public float cameraFollowSpeed = 2f; // Speed of the camera following the knife
    public Vector3 cameraOffset = new Vector3(0, 1, -3); // Offset from the knife

    // Array cache to store the last 10 inputs
    private float[,] inputCache = new float[10, 6];
    private int cacheIndex = 0; // Keeps track of the current index in the cache

    private bool isManualControl = false; //flag for manual cam control

    private float knifeSharpness = 1.0f;  // A constant to represent the sharpness of the knife
    private float skinTensileStrength = 10.0f;  // A constant for the skin's resistance to cutting (this could be a realistic value)

    private Vector3 previousPosition = Vector3.zero;
    private Vector3 currentPosition = Vector3.zero;

    void Start()
    {
        Debug.Log("Ports: " + string.Join(", ", SerialPort.GetPortNames()));

        sp = new SerialPort(portName, baud)
        {
            NewLine = "\n",
            ReadTimeout = readTimeoutMs,
            DtrEnable = true,      // Helpful for many USB CDC adapters
            RtsEnable = true,
            Encoding = Encoding.ASCII
        };

        try
        {
            sp.Open();
            running = true;
            reader = new Thread(ReadLoop) { IsBackground = true };
            reader.Start();
            Debug.Log($"Opened {sp.PortName} @ {baud}");
        }
        catch (Exception ex)
        {
            Debug.LogError("Open failed: " + ex.Message);
        }
    }

    void ReadLoop()
    {
        while (running && sp != null && sp.IsOpen)
        {
            try
            {
                string line = sp.ReadLine();          // blocks until '\n' or timeout
                if (!string.IsNullOrWhiteSpace(line))
                    inbox.Enqueue(line.Trim());
            }
            catch (TimeoutException) { /* ignore */ }
            catch (InvalidOperationException) { break; }     // Port closed
            catch (System.IO.IOException) { /* transient; continue */ }
        }
    }

    void printCache(float[,] arr)
    {
        float x = arr[cacheIndex, 0];
        float y = arr[cacheIndex, 1];
        float z = arr[cacheIndex, 2];
        float yaw = arr[cacheIndex,3];
        float pitch = arr[cacheIndex, 4];
        float roll = arr[cacheIndex, 5];
        Debug.Log("x:" + x + ", y:" + y + ", z:" + z + ", yaw:" + yaw + ", pitch:" + pitch + ", roll:" + roll); 
    }

    // Manual camera movement using keyboard or mouse input
    void ManualCameraControl()
    {
        // Camera follows the knife from a fixed position behind it
        //if (cameraTransform != null)
        //{
        //    Vector3 targetPosition = transform.position + cameraOffset;
        //    cameraTransform.position = Vector3.Lerp(cameraTransform.position, targetPosition, cameraFollowSpeed * Time.deltaTime);
        //    cameraTransform.LookAt(transform);  // Make sure the camera is always looking at the knife
        //}

        Debug.Log("Manual camera movement activated...");

        float horizontal = 0f;
        float vertical = 0f;
        float forward = 0f;

        // Use arrow keys or WASD for movement
        if (Input.GetKey(KeyCode.A)) horizontal = -1f; // Left
        if (Input.GetKey(KeyCode.D)) horizontal = 1f;  // Right
        if (Input.GetKey(KeyCode.W)) forward = 1f;    // forward
        if (Input.GetKey(KeyCode.S)) forward = -1f;   // backward
        if (Input.GetKey(KeyCode.UpArrow)) vertical = 1f;   // up
        if (Input.GetKey(KeyCode.DownArrow)) vertical = -1f;   // down

        // Use mouse to control camera rotation (only when manual control is enabled)
        float mouseX = Input.GetAxis("Mouse X");
        float mouseY = Input.GetAxis("Mouse Y");

        // Move the camera manually using keyboard
        cameraTransform.Translate(new Vector3(horizontal, vertical, forward) * Time.deltaTime * 5f, Space.World);

        // Rotate the camera based on mouse movement
        cameraTransform.Rotate(new Vector3(-mouseY, mouseX, 0) * Time.deltaTime * 100f);

        Debug.Log("Camera movement completed.");
        Debug.Log("Camera Position: " + cameraTransform.position); // Check position
    }

    // Calculate the force to cut through the skin based on the cache data
    public float CalculateCuttingForce()
    {
        // Step 1: Get the knife's velocity from the position data in the cache (use previous and current positions)
        Vector3 velocity = (currentPosition - previousPosition) / Time.deltaTime;

        // Step 2: Calculate the pressure exerted by the knife on the skin
        float pressure = knifeSharpness * velocity.magnitude;  // Magnitude of velocity gives speed

        // Step 3: Estimate the cutting force based on the pressure and a contact area (approximated)
        // Assuming a simple circular contact area (for a knife tip) with a given radius:
        float contactArea = Mathf.PI * Mathf.Pow(0.01f, 2);  // Example: knife tip radius is 0.01 meters (1 cm radius)

        float cuttingForce = pressure * contactArea;

        // Step 4: Compare with skin's tensile strength (if needed)
        if (cuttingForce > skinTensileStrength)
        {
            Debug.Log("Knife can cut through the skin!");
        }
        else
        {
            Debug.Log("Insufficient force to cut through the skin.");
        }

        // Return the calculated cutting force
        return cuttingForce;
    }

    void Update()
    {
        int n = 0;
        while (n++ < 5 && inbox.TryDequeue(out var msg))
        {
            // Debug: log the incoming message
            Debug.Log("Received message: " + msg);

            // Remove the square brackets and split by comma
            string[] parts = msg.Trim('[', ']').Split(',');

            // Add the parsed parts array to the cache

            // Check if there are exactly 7 values (x, y, z, yaw, pitch, roll, moveCam)
            if (parts.Length == 7)
            {  
                try
                {
                    if (float.Parse(parts[6].Trim(), CultureInfo.InvariantCulture) == 1.0f)
                    {
                        ManualCameraControl();
                    } 
                    else //parts[6] == 0
                    {
                        // Convert each part to float using InvariantCulture to avoid issues with locale-specific number formats
                        float x = float.Parse(parts[0].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 0] = x;

                        float y = float.Parse(parts[1].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 1] = y;

                        float z = float.Parse(parts[2].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 2] = z;

                        float yaw = float.Parse(parts[3].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 3] = yaw;

                        float pitch = float.Parse(parts[4].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 4] = pitch;

                        float roll = float.Parse(parts[5].Trim(), CultureInfo.InvariantCulture);
                        inputCache[cacheIndex, 5] = roll;

                        // Use the parsed values to apply movement and rotation
                        Vector3 move = new Vector3(x, y, z);
                        transform.Translate(move * moveSpeed * Time.deltaTime, Space.World);

                        Vector3 rotation = new Vector3(pitch, yaw, roll);
                        transform.Rotate(rotation * rotationSpeed * Time.deltaTime, Space.Self);

                        printCache(inputCache);

                        // Store the current and previous positions from the input cache (simplified for example)
                        previousPosition = currentPosition;
                        currentPosition = new Vector3(inputCache[cacheIndex, 0], inputCache[cacheIndex, 1], inputCache[cacheIndex, 2]);

                        // Call the cutting force calculation
                        float force = CalculateCuttingForce();
                        Debug.Log("Calculated Cutting Force: " + force);
                    }
                }
                catch (FormatException e)
                    {
                        Debug.LogError("Error parsing message: " + msg + ". Exception: " + e.Message);
                    }
            }
            else
            {
                Debug.LogWarning("Invalid message format. Expected 7 values, got " + parts.Length);
            }
        }
    }

    void OnDisable() => ClosePort();
    void OnApplicationQuit() => ClosePort();

    void ClosePort()
    {
        running = false;
        try { reader?.Join(300); } catch { }
        try { if (sp?.IsOpen == true) sp.Close(); } catch { }
        try { sp?.Dispose(); } catch { }
        reader = null; sp = null;
    }
}
